local proto_wg = Proto.new("wg", "WireGuard")
local type_names = {
    [1] = "Handshake Initiation",
    [2] = "Handshake Response",
    [3] = "Cookie Reply",
    [4] = "Transport Data",
}
local F = {
    type        = ProtoField.uint8("wg.type", "Type", base.DEC, type_names),
    reserved    = ProtoField.none("wg.reserved", "Reserved"),
    sender      = ProtoField.uint32("wg.sender", "Sender", base.HEX),
    ephemeral   = ProtoField.bytes("wg.ephemeral", "Ephemeral"),
    mac1        = ProtoField.bytes("wg.mac1", "mac1"),
    mac2        = ProtoField.bytes("wg.mac2", "mac2"),
    receiver    = ProtoField.uint32("wg.receiver", "Receiver", base.HEX),
    nonce       = ProtoField.bytes("wg.nonce", "Nonce"),
    cookie      = ProtoField.bytes("wg.cookie", "Cookie"),
    counter     = ProtoField.uint64("wg.counter", "Counter"),
}
local function add_aead_field(F, name, label)
    F[name] = ProtoField.none("wg." .. name, label .. " (encrypted)")
    -- The "empty" field does not have data, do not bother adding fields for it.
    if name ~= "empty" then
        F[name .. "_ciphertext"] = ProtoField.bytes("wg." .. name .. ".ciphertext", "Ciphertext")
        F[name .. "_data"] = ProtoField.bytes("wg." .. name .. ".data", label)
    end
    F[name .. "_atag"] = ProtoField.bytes("wg." .. name .. ".auth_tag", "Auth Tag")
end
add_aead_field(F, "static", "Static")
add_aead_field(F, "timestamp", "Timestamp")
add_aead_field(F, "empty", "Empty")
add_aead_field(F, "packet", "Packet")
proto_wg.fields = F

-- See function load_keys below for the file format.
proto_wg.prefs.keylog_file = Pref.string("Keylog file", "",
    "Path to keylog file as generated by key-extract.py")

local efs = {}
efs.error               = ProtoExpert.new("wg.expert.error", "Dissection Error",
    expert.group.MALFORMED, expert.severity.ERROR)
efs.bad_packet_length   = ProtoExpert.new("wg.expert.bad_packet_length", "Packet length is too small!",
    expert.group.MALFORMED, expert.severity.ERROR)
efs.decryption_error    = ProtoExpert.new("wg.expert.decryption_error", "Decryption error",
    expert.group.DECRYPTION, expert.severity.NOTE)
proto_wg.experts = efs

-- Length of AEAD authentication tag
local AUTH_TAG_LENGTH = 16

-- Convenience function for consuming part of the buffer and remembering the
-- offset for the next time.
function next_tvb(tvb)
    local offset = 0
    return setmetatable({
        -- Returns the current offset.
        offset = function()
            return offset
        end,
        -- Returns the TVB with the requested length without advancing offset
        peek = function(self, len)
            local t = tvb(offset, len)
            self.tvb = t
            return t
        end,
    }, {
        -- Returns the TVB with the requested length
        __call = function(self, len)
            local t = tvb(offset, len)
            offset = offset + len
            self.tvb = t
            return t
        end,
    })
end

--
-- Decryption helpers (glue)
--
local fromhex = Struct.fromhex
local gcrypt
do
    local ok, res = pcall(require, "luagcrypt")
    if ok then
        gcrypt = res
    else
        report_failure("wg.lua: cannot load Luagcrypt, decryption is unavailable.\n" .. res)
    end
end

--
-- Decryption helpers (independent of Wireshark)
--
KEY_STATIC      = "STAT"
KEY_TIMESTAMP   = "TIME"
KEY_EMPTY       = "EMPT"
KEY_TRAFFIC     = "DATA"

-- Update "keylog" with keys read from "filename".
-- On error, the error message is returned.
local function load_keys(keylog, filename)
    local f, err = io.open(filename)
    if not f then
        -- Opening the keylog file failed, return the error
        return err
    end

    -- Populate subtables.
    for k, v in ipairs({KEY_STATIC, KEY_TIMESTAMP, KEY_EMPTY, KEY_TRAFFIC}) do
        if not keylog[v] then keylog[v] = {} end
    end

    -- Read lines of the format "<type> <peer-id> <hex-encoded key>" where:
    -- "<type>" is one of the key types, "STAT", "TIME", etc. (see KEY_* above),
    -- "<peer-id>" is the 32-bit Sender/Data Receiver ID (e.g. 0x12345678) and
    -- "<hex-encoded key>" is the hex-encoded 32-byte key.  Unrecognized lines
    -- (such as empty lines and lines starting with "#" are ignored).
    while true do
        local line = f:read()
        if not line then break end  -- break on EOF
        local what, peer_id, key = string.match(line, "^(%u+) (0x%x+) (%x+)")
        if what and keylog[what] then
            -- optional authenticated additional data
            local aad = string.match(line, "%x+", #what + #peer_id + #key + 4)
            if aad then aad = fromhex(aad) end
            peer_id = tonumber(peer_id)
            key = fromhex(key)
            keylog[what][peer_id] = {key, aad}
        end
    end
    f:close()
end

-- Try to load a key for the given sender, returning the key and additional
-- authenticated data (possibly nil if there are none) or two nils followed by
-- an error message (if an IO error occured).
local function load_key(keylog, filename, key_type, peer_id)
    local keylog_sub = keylog[key_type]
    if not keylog_sub then
        keylog_sub = {}
        keylog[key_type] = keylog_sub
    end
    if not keylog_sub[peer_id] then
        -- Key ID is not yet known, try to load from file.
        local err = load_keys(keylog, filename)
        if err then
            return nil, nil, err
        end
    end
    local result = keylog_sub[peer_id]
    if result then return table.unpack(result) end
end

local function decrypt_aead_gcrypt(key, counter, encrypted, aad)
    local cipher = gcrypt.Cipher(gcrypt.CIPHER_CHACHA20, gcrypt.CIPHER_MODE_POLY1305)
    cipher:setkey(key)
    local nonce
    if counter == 0 then
        nonce = string.rep("\0", 12)
    else
        -- UInt64 type was passed in
        nonce = Struct.pack("<I4E", 0, counter)
    end
    cipher:setiv(nonce)
    if aad then cipher:authenticate(aad) end
    local plain = cipher:decrypt(encrypted)
    return plain, cipher:gettag()
end
local function decrypt_aead(key, counter, encrypted, tag, aad)
    local ok, plain, calctag = pcall(decrypt_aead_gcrypt, key, counter, encrypted, aad)
    if ok then
        -- Return result and signal error if authentication failed.
        local auth_err = calctag ~= tag and "Authentication tag mismatch, expected " .. Struct.tohex(calctag)
        return plain, auth_err
    else
        -- Return error
        return nil, plain
    end
end
--
-- End decryption helpers.
--

-- Remember previously read keys
local keylog_cache = {}

local function dissect_aead(t, tree, datalen, fieldname, counter, key_type, peer_id)
    -- Builds a tree:
    -- * Foo (Encrypted)
    --   * Ciphertext
    --   * Auth Tag
    local subtree = tree:add(F[fieldname], t:peek(datalen + AUTH_TAG_LENGTH))
    local encr_tvb, atag_tvb
    if datalen > 0 then
        subtree:add(F[fieldname .. "_ciphertext"], t(datalen))
        encr_tvb = t.tvb
    end
    subtree:add(F[fieldname .. "_atag"], t(AUTH_TAG_LENGTH))
    atag_tvb = t.tvb

    -- Try to decrypt and authenticate if possible.
    if gcrypt then
        local key, err, keylog_file
        keylog_file = proto_wg.prefs.keylog_file
        while keylog_file and keylog_file ~= "" do
            -- Try to load key
            key, aad, err = load_key(keylog_cache, keylog_file, key_type, peer_id)
            if not key then break end

            -- Decrypt and authenticate the buffer
            local encr_data = encr_tvb and encr_tvb:raw() or ""
            local decrypted
            decrypted, err = decrypt_aead(key, counter, encr_data, atag_tvb:raw(), aad)
            if not decrypted then break end
            if decrypted ~= "" then
                -- TODO hide this if auth tag is bad
                local decr_tvb = ByteArray.new(decrypted, true)
                    :tvb("Decrypted " .. fieldname)
                subtree:add(F[fieldname .. "_data"], decr_tvb())
            end
            -- Skip further processing if authentication tag failed
            if err then break end

            -- TODO return tvb to caller?

            break
        end
        -- If any decryption error occurred, show it.
        if err then
            subtree:add_proto_expert_info(efs.decryption_error, err)
        end
    end
end

function dissect_initiator(tvb, pinfo, tree)
    local t = next_tvb(tvb)
    tree:add(F.type,        t(1))
    tree:add(F.reserved,    t(3))
    tree:add_le(F.sender,   t(4))
    local sender_id = t.tvb:le_uint()
    pinfo.cols.info:append(string.format(", sender=0x%08X", sender_id))
    tree:add(F.ephemeral,   t(32))
    dissect_aead(t, tree, 32, "static", 0, KEY_STATIC, sender_id)
    dissect_aead(t, tree, 12, "timestamp", 0, KEY_TIMESTAMP, sender_id)
    tree:add(F.mac1,        t(16))
    tree:add(F.mac2,        t(16))
    return t:offset()
end

function dissect_responder(tvb, pinfo, tree)
    local t = next_tvb(tvb)
    tree:add(F.type,        t(1))
    tree:add(F.reserved,    t(3))
    tree:add_le(F.sender,   t(4))
    local sender_id = t.tvb:le_uint()
    pinfo.cols.info:append(string.format(", sender=0x%08X", sender_id))
    tree:add_le(F.receiver, t(4))
    pinfo.cols.info:append(string.format(", receiver=0x%08X", t.tvb:le_uint()))
    tree:add(F.ephemeral,   t(32))
    dissect_aead(t, tree, 0, "empty", 0, KEY_EMPTY, sender_id)
    tree:add(F.mac1,        t(16))
    tree:add(F.mac2,        t(16))
    return t:offset()
end

function dissect_cookie(tvb, pinfo, tree)
    local t = next_tvb(tvb)
    tree:add(F.type,        t(1))
    tree:add(F.reserved,    t(3))
    tree:add_le(F.receiver, t(4))
    pinfo.cols.info:append(string.format(", receiver=0x%08X", t.tvb:le_uint()))
    tree:add(F.nonce,       t(24))
    dissect_aead(t, tree, 16, "cookie")
    return t:offset()
end

function dissect_data(tvb, pinfo, tree)
    local t = next_tvb(tvb)
    tree:add(F.type,        t(1))
    tree:add(F.reserved,    t(3))
    tree:add_le(F.receiver, t(4))
    local receiver_id = t.tvb:le_uint()
    pinfo.cols.info:append(string.format(", receiver=0x%08X", receiver_id))
    tree:add_le(F.counter,  t(8))
    local counter = t.tvb:le_uint64()
    pinfo.cols.info:append(string.format(", counter=%s", counter))
    local packet_length = tvb:len() - t:offset()
    if packet_length < AUTH_TAG_LENGTH then
        -- Should not happen, it is a malformed packet.
        tree:add_tvb_expert_info(efs.bad_packet_length. t(packet_length))
        return t:offset()
    end
    local datalen = packet_length - AUTH_TAG_LENGTH
    if datalen > 0 then
        pinfo.cols.info:append(string.format(", datalen=%s", datalen))
    end
    dissect_aead(t, tree, datalen, "packet", counter, KEY_TRAFFIC, receiver_id)
    return t:offset()
end

local types = {
    [1] = dissect_initiator,
    [2] = dissect_responder,
    [3] = dissect_cookie,
    [4] = dissect_data,
}

function proto_wg.dissector(tvb, pinfo, tree)
    if tvb:len() < 4 then return 0 end
    local type_val = tvb(0,1):uint()
    -- "Reserved" must be zero at the moment
    if tvb(1,3):uint() ~= 0 then return 0 end

    local subdissector = types[type_val]
    if not subdissector then return 0 end

    pinfo.cols.protocol = "WireGuard"
    pinfo.cols.info = type_names[type_val]
    local subtree = tree:add(proto_wg, tvb())
    local success, ret = pcall(subdissector, tvb, pinfo, subtree)
    if success then
        return ret
    else
        -- An error has occurred... Do not propagate it since Wireshark would
        -- then try a different heuristics dissectors.
        subtree:add_proto_expert_info(efs.error, ret)
        return tvb:len()
    end
end

proto_wg:register_heuristic("udp", proto_wg.dissector)
